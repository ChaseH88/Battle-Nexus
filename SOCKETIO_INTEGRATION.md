# Socket.io Integration Pattern for Battle Nexus

This document outlines the recommended pattern for integrating the replay system with Socket.io for real-time multiplayer.

## Architecture Overview

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│  Player 1   │         │   Server    │         │  Player 2   │
│   Client    │         │  (Node.js)  │         │   Client    │
└─────────────┘         └─────────────┘         └─────────────┘
      │                        │                        │
      │  1. Action Event       │                        │
      ├───────────────────────>│                        │
      │                        │                        │
      │                        │  2. Validate Action    │
      │                        │     Generate Events    │
      │                        │                        │
      │  3. Confirmation       │                        │
      │<───────────────────────┤                        │
      │                        │                        │
      │                        │  4. Replay Events      │
      │                        ├───────────────────────>│
      │                        │                        │
      │                        │                        │
      │                        │  5. Player 2 Action    │
      │                        │<───────────────────────┤
      │                        │                        │
      │  6. Replay Events      │                        │
      │<───────────────────────┤                        │
      │                        │                        │
```

## Event Protocol

### 1. Game Initialization

**Client → Server**
```typescript
socket.emit('joinGame', {
  gameId: string,
  playerId: string,
  playerName: string
});
```

**Server → Clients**
```typescript
socket.emit('gameStarted', {
  gameId: string,
  players: [
    { id: string, name: string, index: 0 },
    { id: string, name: string, index: 1 }
  ],
  initialEvents: GameLogEvent[],  // GAME_START, TURN_START, etc.
  yourPlayerIndex: 0 | 1
});
```

### 2. Player Actions

**Client → Server**
```typescript
// Player performs action
socket.emit('playerAction', {
  gameId: string,
  playerId: string,
  sequenceNumber: number,  // For ordering/validation
  action: {
    type: 'DRAW_CARD' | 'PLAY_CREATURE' | 'PLAY_SUPPORT' | 'ATTACK' | 'END_TURN',
    payload: any  // Action-specific data
  }
});
```

### 3. Server Processing

**Server Side (Node.js + TypeScript)**
```typescript
import { BattleEngine } from './battle/BattleEngine';
import { exportGameLog } from './battle/ReplayEngine';

// Server maintains authoritative game state
const gameStates = new Map<string, BattleEngine>();

io.on('connection', (socket) => {
  socket.on('playerAction', async (data) => {
    const { gameId, playerId, sequenceNumber, action } = data;
    
    // Get authoritative game state
    const engine = gameStates.get(gameId);
    if (!engine) return;
    
    // Validate it's this player's turn
    const playerIndex = getPlayerIndex(gameId, playerId);
    if (engine.state.players[playerIndex].id !== playerId) {
      socket.emit('error', { message: 'Not your turn' });
      return;
    }
    
    // Get sequence before action
    const eventsBefore = engine.logger.getEvents().length;
    
    // Execute action
    let success = false;
    switch (action.type) {
      case 'DRAW_CARD':
        engine.draw(playerIndex);
        success = true;
        break;
      case 'PLAY_CREATURE':
        success = engine.playCreature(
          playerIndex,
          action.payload.lane,
          action.payload.cardId,
          action.payload.faceDown,
          action.payload.mode
        );
        break;
      case 'ATTACK':
        success = engine.attack(
          action.payload.attackerLane,
          action.payload.targetPlayerIndex,
          action.payload.targetLane
        );
        break;
      // ... other actions
    }
    
    if (!success) {
      socket.emit('actionFailed', { message: 'Invalid action' });
      return;
    }
    
    // Get new events generated by this action
    const eventsAfter = engine.logger.getEvents();
    const newEvents = eventsAfter.slice(eventsBefore);
    
    // Send confirmation to acting player
    socket.emit('actionConfirmed', {
      sequenceNumber,
      events: newEvents
    });
    
    // Send replay events to opponent
    const opponentSocket = getOpponentSocket(gameId, playerId);
    if (opponentSocket) {
      opponentSocket.emit('opponentAction', {
        playerId,
        events: newEvents
      });
    }
    
    // Check for game end
    if (engine.state.winnerIndex !== null) {
      io.to(gameId).emit('gameEnded', {
        winner: engine.state.players[engine.state.winnerIndex].id,
        finalEvents: engine.logger.getEvents(),
        exportData: exportGameLog(engine.logger.getEvents(), {
          player1Name: engine.state.players[0].id,
          player2Name: engine.state.players[1].id,
          winner: engine.state.players[engine.state.winnerIndex].id,
          duration: Date.now() - gameStartTime
        })
      });
    }
  });
});
```

### 4. Client Replay

**Client Side (React)**
```typescript
import { ReplayEngine } from './battle/ReplayEngine';
import { restoreStateFromSnapshot } from './battle/UndoManager';

// Listen for opponent actions
socket.on('opponentAction', ({ playerId, events }) => {
  // Create replay engine for smooth animation
  const replay = new ReplayEngine(events, {
    speed: 1,
    autoPlay: true,
    onEventReplay: (event, state) => {
      // Animate each event
      animateEvent(event);
      
      // Update local game state
      if (event.stateSnapshot) {
        restoreStateFromSnapshot(localGameState, event.stateSnapshot);
      }
      
      // Update UI
      updateGameUI(localGameState);
    },
    onComplete: () => {
      console.log('Opponent turn replay complete');
    }
  });
});

// Handle your own action confirmation
socket.on('actionConfirmed', ({ sequenceNumber, events }) => {
  // Your action was validated
  // Update local state with server's events
  events.forEach(event => {
    localGameState.log.log(event);
  });
  
  updateGameUI(localGameState);
});
```

## State Synchronization Strategy

### Optimistic Updates (Optional)
```typescript
// Client predicts action outcome
function performAction(action: Action) {
  // 1. Apply locally for instant feedback
  const localResult = applyActionLocally(action);
  updateUI(localGameState);
  
  // 2. Send to server
  socket.emit('playerAction', {
    gameId,
    playerId,
    sequenceNumber: nextSequence++,
    action
  });
  
  // 3. Wait for confirmation
  socket.once('actionConfirmed', ({ events }) => {
    // Verify local state matches server
    const serverSnapshot = events.find(e => e.stateSnapshot)?.stateSnapshot;
    if (serverSnapshot) {
      if (!statesMatch(localGameState, serverSnapshot)) {
        // Rollback and apply server state
        restoreStateFromSnapshot(localGameState, serverSnapshot);
        console.warn('State mismatch - using server state');
      }
    }
  });
}
```

### Conservative Updates (Recommended)
```typescript
// Wait for server confirmation before updating
function performAction(action: Action) {
  // Show loading state
  setActionPending(true);
  
  // Send to server
  socket.emit('playerAction', {
    gameId,
    playerId,
    sequenceNumber: nextSequence++,
    action
  });
  
  // Wait for confirmation
  socket.once('actionConfirmed', ({ events }) => {
    // Apply server's events
    const replay = new ReplayEngine(events, {
      speed: 2,  // Fast replay for your own actions
      autoPlay: true,
      onEventReplay: (event, state) => {
        if (event.stateSnapshot) {
          restoreStateFromSnapshot(localGameState, event.stateSnapshot);
        }
        updateGameUI(localGameState);
      },
      onComplete: () => {
        setActionPending(false);
      }
    });
  });
}
```

## Handling Disconnects

### Server Side
```typescript
// Store game state periodically
const gameSnapshots = new Map<string, string>();

setInterval(() => {
  gameStates.forEach((engine, gameId) => {
    const events = engine.logger.getEvents();
    gameSnapshots.set(gameId, exportGameLog(events));
  });
}, 5000); // Every 5 seconds

socket.on('disconnect', () => {
  // Mark player as disconnected
  markPlayerDisconnected(gameId, playerId);
  
  // Give them 60 seconds to reconnect
  setTimeout(() => {
    if (isStillDisconnected(gameId, playerId)) {
      // Forfeit game
      endGameByDisconnect(gameId, playerId);
    }
  }, 60000);
});
```

### Client Side
```typescript
socket.on('reconnect', async () => {
  // Request game state sync
  socket.emit('syncGameState', {
    gameId,
    playerId,
    lastEventSequence: localGameState.log.getEvents().length
  });
});

socket.on('gameStateSync', ({ events, startSequence }) => {
  // Get only events we're missing
  const missingEvents = events.filter(e => e.seq >= startSequence);
  
  // Replay to catch up
  const replay = new ReplayEngine(missingEvents, {
    speed: 3,  // Fast catch-up
    autoPlay: true,
    onEventReplay: (event, state) => {
      if (event.stateSnapshot) {
        restoreStateFromSnapshot(localGameState, event.stateSnapshot);
      }
    },
    onComplete: () => {
      console.log('Caught up to current game state');
    }
  });
});
```

## Spectator Mode

```typescript
// Server side
socket.on('spectateGame', ({ gameId }) => {
  const engine = gameStates.get(gameId);
  if (!engine) return;
  
  // Add to spectator room
  socket.join(`${gameId}-spectators`);
  
  // Send full event history
  socket.emit('spectatorJoined', {
    gameId,
    events: engine.logger.getEvents(),
    players: engine.state.players.map(p => ({ id: p.id, name: p.id }))
  });
});

// Broadcast new events to spectators
io.to(`${gameId}-spectators`).emit('gameUpdate', {
  events: newEvents
});

// Client side (spectator)
socket.on('spectatorJoined', ({ events, players }) => {
  // Start replay from beginning
  const replay = new ReplayEngine(events, {
    speed: 1.5,
    autoPlay: true,
    onEventReplay: (event, state) => {
      updateSpectatorUI(state, event);
    }
  });
});

socket.on('gameUpdate', ({ events }) => {
  // Continue replay with new events
  currentReplay.appendEvents(events);
});
```

## Security Considerations

1. **Server Authority**: Server maintains authoritative game state
2. **Action Validation**: All actions validated server-side
3. **No Hidden Info**: Snapshots exclude deck/hand contents
4. **Sequence Numbers**: Prevent replay attacks
5. **Turn Validation**: Verify it's player's turn before processing
6. **Rate Limiting**: Prevent action spam

## Performance Tips

1. **Batch Events**: Send multiple events in one message
2. **Snapshot Frequency**: Balance between replay speed and memory
3. **Event Pruning**: Remove very old events after game ends
4. **Compression**: Use gzip for event transmission
5. **Selective Broadcasting**: Only send events to relevant clients

## Example: Complete Game Flow

```typescript
// 1. Start game
socket.emit('joinGame', { gameId: 'abc123', playerId: 'p1', playerName: 'Alice' });

// 2. Receive initial state
socket.on('gameStarted', ({ initialEvents, yourPlayerIndex }) => {
  initializeGame(initialEvents, yourPlayerIndex);
});

// 3. Your turn - draw card
socket.emit('playerAction', {
  gameId: 'abc123',
  playerId: 'p1',
  sequenceNumber: 1,
  action: { type: 'DRAW_CARD', payload: {} }
});

// 4. Server confirms
socket.on('actionConfirmed', ({ events }) => {
  replayEvents(events);  // CARD_DRAWN, PHASE_CHANGE
});

// 5. Play creature
socket.emit('playerAction', {
  gameId: 'abc123',
  playerId: 'p1',
  sequenceNumber: 2,
  action: { 
    type: 'PLAY_CREATURE',
    payload: { cardId: 'fire-sprite', lane: 0, faceDown: false, mode: 'ATTACK' }
  }
});

// 6. Opponent's turn
socket.on('opponentAction', ({ playerId, events }) => {
  replayOpponentTurn(events);  // Smooth animation
});

// 7. Game ends
socket.on('gameEnded', ({ winner, exportData }) => {
  if (winner === playerId) {
    showVictory();
  } else {
    showDefeat();
  }
  
  // Save replay for later viewing
  saveReplay(exportData);
});
```

This pattern provides:
- ✅ Real-time synchronization
- ✅ Smooth animations
- ✅ Automatic reconnection
- ✅ Spectator support
- ✅ Full game history
- ✅ Replay capability
